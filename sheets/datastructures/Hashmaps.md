#### Contents
  *
  
  
* Hashmap is a data-structure that stores the data in key-value pairs. 

* Two main functions provided by hashmap are: ```void put(Object key, Object value)``` for storing and ```Object get(Object key)```for retrieving values from HashMap. 

* Time complexity of both functions is O(1).


### Direct Access Table

* One simple approach would be to implement such a data structure would be by using array to keep values. This is called **Direct Access Table**. 
* Here index of the array will be the key.
* Whatever key is not used, we will keep null there.
* Running Time: Insert: O(1), Search: O(1) and Delete: O(1)
* **What's bad?** : 
  1. **Keys can be any data type**: It will be hard to associate every key with an integer.
  2. **Gigantic memory hog**: If the set of possible keys will be very large, we will have to create a really big array, occupying more space.
  
  ### Prehashing
  
* Soultion to keys may not be integers: Map the keys non-negative integers to keep them in Direct Access Table. This is called 
**Prehashing**. (This can be done because every object can be written down as array of bits which is a string).
 
 * In Java, prehashing is done using the ```hashCode()``` method.
 
 * Prehash function should not change values overtime. Suppose if you have an item which we wish to put in the hashmap. We compute the hash prehash of the key and then we put the item in the direct access tabl with index with prehash(key). And we want to search for that item in the table, and we call prehash(key) to get the index of the table in which the item is kept, Now if the value of prehash(key) change, we can not find the item.
 
 ### Hashing

* This is solution to gigantic size of the Direct Access Table. With hashing we will try to reduce the universe of all keys down to reasonable size for the table.

* Suppose there are n possible keys, (i.e. n key-value pairs need to be stored in the hashmap). We will try to reduce them to a resonable size m for table. i.e the size of array will be m.

* We would like to somehow map these n possible keys to a smaller set using a hash function.


### Collision:

* The number of slots in the table is wat smaller than  the possible number of keys.

* So there are going to be two keys k<sub>i</sub> and k<sub>j</sub> which are different keys, but they map to same slot in the hash map.

* i.e hash(k<sub>i</sub>) = hash(k<sub>j</sub>) but k<sub>i</sub> != k<sub>j</sub>


#### Chaining

* Technique to deal with collision.

* If you have multiple items whose keys are generating same hash index, store all the itesm as a list to that index.

* So each slot of the array is actually a list which can contain multiple items.

* There will be a lot of keys which will map to the same slot. 
* Worst case of retrieving an item: O(n) This will be true for any hashing scheme we use.

* But in practice, hashing works really well. Good hash() nicely distributes the items in hash map and most of the lists in the indices will have constant length.


#### Analysis

* Expected length of one chain: Assuming thatt each key is equally likely to be hashed to any slot of the table, For n keys which we need to store in a table and m slots in the map, each chain length will be n/m. This is known as the load factor of Hash Map. (loadFactor = n/m).

* Running time of get and put operation: 
  * Constant time to calculate hash function + Time taken to insert/ search an element in the list of index generated by hash function (n/m or loadFactor).
  * So time complexity: O(1+loadFactor).  
  * For cases when the loadFactor < 1. When the size of table(number of buckets) is larger than number of keys: O(1)
  * For cases when the loadFactor >= 1. O(loadFactor) or constant time.
  
### Implementation
