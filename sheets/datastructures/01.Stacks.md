### Contents
  *  [Array Implementation of Stack](#array-implementation-of-stack)
  *  [LinkedList implementation of Stack](#linkedlist-implementation-of-stack)
  *  [Implement a MinStack](#implement-a-minstack)
  *  [Implement a Stack using Queues](#implement-a-stack-using-queues)
  *  [Implement a Stack using one Queue](#implement-a-stack-using-one-queue)
  *  [Reverse words of a String](#reverse-words-of-a-string)
  *  [Check validity of expression having nested paranthesis](#)
  *  [Convert infix polish notation to prefix notation](#)
  
 ## STACKS
 - Stack is a linear data structure in which insertion and deletion happen only from one end, called the top of stack.
 - Stack follows LIFO (Last In First Out)principle, meaning the element which was inserted in the stack at last is removed first.
 - Stack allows following operations
   -  push() - pushes an element at top of stack
   -  pop() - returns the topmost element after removing it from stack
   -  isEmpty() - returns if the stack is Empty.
   -  peek() - returns the topmost element without removing it from stack
 #### Array Implementation of Stack
 ``` java
 public class Stack {

    private static final int MAX_SIZE = 1000;

    private int[] stack_arr = new int[MAX_SIZE];

    //Initially when the stack is empty, top is initialized with -1
    private int top = -1;

    public void push(int data) {
        if (isFull()) {
            System.out.println("Stack Overflow");
            return;
        }
        top++;
        stack_arr[top] = data;

    }

    public int pop() {
        if (isEmpty()) {
            System.out.println("Stack Underflow");
            return Integer.MIN_VALUE;
        }

        int data = stack_arr[top];
        top--;
        return data;
    }

    public int peek() {
        if (isEmpty()) {
            System.out.println("Stack Empty");
            return Integer.MIN_VALUE;
        }

        return stack_arr[top];

    }

    public boolean isEmpty() {
        return top == -1;
    }

    public boolean isFull() {
        return top == MAX_SIZE - 1;
    }

}
 ```
#### LinkedList implementation of Stack
- When size of Stack is not known in advance, it is better to implement it as Linked List. In this case datastructures.stack will not overflow till there is space available for memory allocation.
- Use beginning of the list as the top of datastructures.stack. For push operation, a node will be inserted in the beginning of list.For pop operation an element will be deleted from the starting of the list. This will ensure LIFO pattern.
- If we take the end of list as the top ofstack, we will have to traverse the whole list for inserting and deleting elements.


```java
public class StackLL {

    SingleLinkedList linkedList = new SingleLinkedList();


    public boolean isEmpty() {
        return linkedList.isListEmpty();
    }

    public void push(int data) {
        linkedList.addAtBeginning(data);
    }

    public int pop() {
        if (isEmpty()) {
            System.out.println("Stack Underflow.");
            return Integer.MIN_VALUE;
        }

        return linkedList.deleteAtBeginning();
    }

    public int peek() {
        if (isEmpty()) {
            System.out.println("Stack Underflow.");
            return Integer.MIN_VALUE;
        }

        return linkedList.displayElementAtBeginning();
    }


    private class SingleLinkedList {

        Node head = null;

        class Node {
            int data;
            Node next;

            Node(int data) {
                this.data = data;
            }
        }


        private boolean isListEmpty() {
            return head == null;
        }

        private void addAtBeginning(int data) {
            Node newNode = new Node(data);
            newNode.next = head;
            head = newNode;
            return;
        }

        private int deleteAtBeginning() {
            if (isListEmpty()) {
                return Integer.MIN_VALUE;
            }

            int data = head.data;
            head = head.next;
            return data;
        }

        private int displayElementAtBeginning() {
            if (isListEmpty()) {
                return Integer.MIN_VALUE;
            }

            return head.data;
        }

    }

}
```

#### Implement a MinStack

* **Problem** Design a Data Structure SpecialStack that supports all the stack operations like push(), pop(), isEmpty(), isFull() and an additional operation getMin() which should return minimum element from the SpecialStack. All these operations of SpecialStack must be O(1). To implement SpecialStack, you should only use standard Stack data structure and no other data structure like arrays, list, .. etc.

* **Solution** Use two stacks: one to store actual stack elements and other as an auxiliary stack to store minimum values. The idea is to do push() and pop() operations in such a way that the top of auxiliary stack is always the minimum. Let us see how push() and pop() operations work.

**Push(int x)** // inserts an element x to Special Stack 
1) push x to the first stack (the stack with actual elements)
2) compare x with the top element of the second stack (the auxiliary stack). Let the top element be y.
  a) If x is smaller than y then push x to the auxiliary stack.
  b) If x is greater than y then push y to the auxiliary stack.

**int Pop()** // removes an element from Special Stack and return the removed element 
1) pop the top element from the auxiliary stack.
2) pop the top element from the actual stack and return it.

The step 1 is necessary to make sure that the auxiliary stack is also updated for future operations.

**int getMin()** // returns the minimum element from Special Stack 
1) Return the top element of auxiliary stack.

We can see that all above operations are O(1).

```java
public class MinStack {

    java.util.Stack<Integer> stack,auxiliaryStack;

    /** initialize your data structure here. */
    public MinStack() {
        stack = new java.util.Stack<>();
        auxiliaryStack = new java.util.Stack<>();
    }

    public void push(int x) {

        if(stack.isEmpty() || x<= auxiliaryStack.peek())
            auxiliaryStack.push(x);
        stack.push(x);
    }

    public void pop() {
        if(stack.isEmpty())
            return;

        if(stack.peek().equals(auxiliaryStack.peek())){
            stack.pop();
            auxiliaryStack.pop();
        }
        else stack.pop();

    }

    public int top() {
        if(stack.isEmpty())
            return Integer.MAX_VALUE;
        return stack.peek();

    }

    public int getMin() {
        if(auxiliaryStack.isEmpty())
            return Integer.MAX_VALUE;
        return auxiliaryStack.peek();
    }
}
```

#### Implement a Stack using Queues

* We are given a Queue data structure that supports standard operations like enqueue() and dequeue(). We need to implement a Stack data structure using only instances of Queue and queue operations allowed on the instances.
* A stack can be implemented using two queues, q1 and q2.
* The idea is to make **pop operation costly**. Wheneever a new element comes, enqueue it it q1. When you need to pop, dequeue all elements from q1 and enqueue them in q1, except the last element. Then transfer all elements from q2 to q1.
* push(s,  x)
  1) Enqueue x to q1 (assuming size of q1 is unlimited).
* pop(s)  
  1) One by one dequeue everything except the last element from q1 and enqueue to q2.
  2) Dequeue the last item of q1, the dequeued item is result, store it.
  3) Swap the names of q1 and q2(Swapping of names is done to avoid one more movement of all elements from q2 to q1.)
  4) Return the item stored in step 2.
  
```java

```

#### Implement a Stack using one Queue
* We can implement a stack using a single queue as well. The solution however assumes that the ADT Queue we are using has a method size() which can give us the size of the queue.
* The idea is to keep the newly inserted element always at the front, so the pop() operation can be performed in O(1). However for a push() operation, Enqueue the new element in the queue, and then keep dequeuing the elements from the queue, (except the new element) and enqueu them back to queue.

* push(s, x) // x is the element to be pushed and s is stack
  1) Let size of q be s. 
  1) Enqueue x to q
  2) One by one Dequeue s items from queue and enqueue them.
  
* pop(s) // Removes an item from stack
  1) Dequeue an item from q
  
  
 ```java
 
 public class stack 
{
    Queue<Integer> q = new LinkedList<Integer>();
     
    // Push operation
    void push(int val) 
    {
        // get previous size of queue
        int size = q.size();
         
        // Add current element
        q.add(val);
         
        // Pop (or Dequeue) all previous
        // elements and put them after current
        // element
        for (int i = 0; i < size; i++) 
        {
            // this will add front element into
            // rear of queue
            int x = q.remove();
            q.add(x);
        }
    }
     
    // Removes the top element
    int pop() 
    {
        if (q.isEmpty()) 
        {
            System.out.println("No elements");
            return -1;
        }
        int x = q.remove();
        return x;
    }
     
    // Returns top of stack
    int top() 
    {
        if (q.isEmpty())
            return -1;
        return q.peek();
    }
     
    // Returns true if Stack is empty else false
    boolean isEmpty() 
    {
        return q.isEmpty();
    }
 
    // Driver program to test above methods
    public static void main(String[] args) 
    {
        stack s = new stack();
        s.push(10);
        s.push(20);
        System.out.println("Top element :" + s.top());
        s.pop();
        s.push(30);
        s.pop();
        System.out.println("Top element :" + s.top());
    }
 
 ```


#### Reverse words of a String

* Let the input string be “i like this program very much”. The function should change the string to “much very program this like i”.

* Approach 1: The problem can be solved using two stacks. 
  1)  Insert all the characters of string in stack1. 
  2)  pop element from stack1 and push it in stack2.
  3)  When space is encountered in stack1, pop all the elements from stack2 and append it to output string.
  4)  When stack1 is empty, return the output string.
 
 
 * Approach 2 
  1) Reverse the individual words, we get the below string.
     ```"i ekil siht margorp yrev hcum"```
  2) Reverse the whole string from start to end and you get the desired output.
     ```"much very program this like i"```
