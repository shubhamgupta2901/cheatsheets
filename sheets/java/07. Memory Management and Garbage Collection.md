## Contents
  * [Introduction](#introduction)
  * [The Stack and the Heap](#the-stack-and-the-heap)
  * [Methods are stacked](#methods-are-stacked)
  * [What about local variables that are objects](#what-about-local-variables-that-are-objects)
  * [Where do instance variables live](#where-do-instance-variables-live)
  * [Object creation](#object-creation)
  
  
 
### Introduction

* Objects are born and objects die. They have their own lifecycle which we decide. We decide when and how we **construct** it, and we decide when we **destroy** them.
* But in Java,we don't actually *destroy* them, we simply abandon them. Once these objects are abandoned, **Garbage Collector(gc)**, destroys them and reclaims the memory that the object was using. Without garbage collection, we risk running our of RAM.
* So we need to have a basic understanding about how objects are created, where they live while they are alive, and how to keep and abandon them effeciently.
* Knowing the fundamentals of the Java Stack and Heap is crucial if you want to understand variable scope, object creation issues, memory management, threads, and exception handling. 

### The Stack and the Heap

* In JAVA, we care about two areas of memory - **Heap** (*also known as garbage collectible heap*)- where objects live and **Stack** - where method invocations and local variables live.
* When a JVM starts up, it gets a chunk of memory from the underlying OS and it uses it to run our JAVA program.

* **Where variable live?** Where a variable lives depends on what kind of variable it is. By *kind* we don't mean *type* (primitive or object reference). The two kinds of variables are *Instance variables* and *local variables*. Local variables are also refered as stack variables.

* **Instance variables**: Instance variables are declared inside a class but *not* inside a method.They represent the fields that each object has, which can be filled with different values, for each instance of class. Instance variables live inside the object they belong to.Eg variables like ```size`` below:
```java
public class Duck{
  int size;
}
```

* **Local Variable**: Local variables are declared inside a method, including method parameters. They are temporary and live only as long as the method is on the stack. (In other words, as long as the method has not reached the closing curly braces.). In below snippet, the parameter ```x``` and variables ```i``` and ```b``` are all local variables. 

```java
public void foo(int x){
    int i = x+3;
    boolean b =true;
}
```

### Methods are stacked
* When we call a method, the method is pushed into the top of **call stack**. This thing which is pushed is called as *stack frame*, it holds the state of the method including the value of local variables, which line of code is executing etc.

*The method at the top of the stack is always the currently-running method for that stack. A method stays on the stack until the method hits its closing curly brace (which means the method’s done). If method ```foo()``` calls method ```bar()```, method ```bar()``` is stacked on top of method ```foo()```.

* Look at the below snippet:

```java
public void doStuff() {
   boolean b = true;
   go(4);
}
public void go(int x) {
   int z = x + 24;
   crazy();
   // imagine more code here
}
public void crazy() {
   char c = 'a';
}
```

* The code has three methods. The first method ```doStuff()``` calls the second method ```go()```, and the second method calls the third ```crazy()```. Each method declares one local variable within the body of the method, and method ```go()``` also declares a parameter variable (which means ```go()``` has two local variables).This is what happens in the call stack:
  * Code from another class calls ```doStuff()```, and ```doStuff()``` goes into a stack frame at the top of the stack.The boolean variable named ```b``` goes on the ```doStuff()``` stack frame.
  * ```doStuff()``` calls ```go()```, ```go()``` is pushed on top of the stack. Variables ```x``` and ```z``` are in the ```go()``` stack frame.
  * ```go()``` calls ```crazy()```, ```crazy()``` is now on the top of the stack, with variable ```c``` in the frame.
  * ```crazy()``` completes, and its stack frame is popped off the stack. Execution goes back to the ```go()``` method, and picks up at the line following the call to ```crazy()```.

### What about local variables that are objects?

* Remember, a non-primitive variable holds a *reference* to an object, not the object itself. We already know where objects live — on the heap. It doesn’t matter where they’re declared or created. **If the local variable is a reference to an object, only the variable (the reference/remote control) goes on the stack.The object itself still goes in the heap.**

```java
public class StackRef {
   public void foof() {
      barf();
   }

   public void barf() {
      Duck d = new Duck(24);
   }
}
```

![hfj](https://github.com/shubhamgupta2901/cheatsheets/blob/master/assets/Screenshot%20from%202018-08-09%2000-02-02.png)


### Where do instance variables live

*  **Instance variables live on the Heap, inside the object they belong to.** 

```java
public class CellPhone {
  private Antenna ant = new Antenna();
}
```

* When you say new ```CellPhone()```, Java has to make space on the Heap for that ```CellPhone``` object. But how much space? Enough for the object, which means enough to house all of the object’s instance variables.

* **Primitive Instance variable**: Remember that the values of an object’s instance variables live inside the object. If the instance variables are all primitives, Java makes space for the instance variables based on the primitive type. An ```int``` needs 32 bits, a ```long``` 64 bits, etc. Java doesn’t care about the value inside primitive variables; the bit-size of an ```int``` variable is the same (32 bits) whether the value of the ```int``` is 32,000,000 or 32.

```java
public class CellPhone {
  int x;
}
```

* **non-primitive Instance variables**: But what if the instance variables are objects? Like in our example , CellPhone has a reference variable of type Antenna.

```java
public class CellPhone {
  private Antenna ant = new Antenna();
}
```
* When the new object has instance variables that are object references rather than primitives, the real question is: does the object need space for all of the objects it holds references to? The answer is, *not exactly*. No matter what, Java has to make space for the instance variable values. But remember that a **reference variable value is not the whole object, but merely a reference to the object**. So if ```CellPhone``` has an instance variable declared as the non-primitive type ```Antenna```, Java makes space within the ```CellPhone``` object only for the ```Antenna’s``` reference (i.e. reference variable) but not the ```Antenna``` object.

* Well then when does the ```Antenna``` object get space on the Heap? First we have to find out when the ```Antenna``` object itself is created. That depends on the instance variable declaration. If the instance variable is declared but no object is assigned to it, then only the space for the reference variable  is created.No actual Antenna object is made on the heap unless or until the reference variable is assigned a new Antenna object like below:

```java
public class CellPhone {
  private Antenna ant = new Antenna();
}
```
### Object creation

* Now that we know where variables and objects live, we can understand object creation. 

* There are three steps of object declaration and assignment: 
  * declare a reference variable,
  * create an object
  * and assign the object to the reference.

* So when an object is created (because somebody said new)), the object gets space for all the instance variables, from all the way up the inheritance tree.  When an object is created, it’s almost as though multiple objects materialize—the object being created and one object per each superclass. But it’s much better to think of it like the picture below, where the object being created has layers of itself representing each superclass.

* So when a new object is created, only one object gets space in the heap- the one which is created.But it contains all the parts of itself, and the super class parts of itself which it inherited. All instance variables from both class have to be here.
* For example if we create a class, it always has a parent, ```Object``` class. So when we write following code:

```java
public class Snowboard{
 Foo x, y;
 int z;
}
```

![object creation](https://github.com/shubhamgupta2901/cheatsheets/blob/master/assets/Screenshot%20from%202018-08-09%2000-54-02.png)

