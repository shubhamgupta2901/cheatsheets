## Contents
* [Basics](#basics)
  * [The Stack and the Heap](#the-stack-and-the-heap)
  * [Kinds of variables](#kinds-of-variables)
  * [Where do methods live](#where-do-methods-live)
  * [Where do local variables live](#where-do-local-variables-live)
  * [Where do instance variables live](#where-do-instance-variables-live)
  * [Object creation](#object-creation)
  * [Life of an object](#life-of-an-object)
 * [Memory Model](#memory-model)
 * [Garbage Collection](#garbage-collection)
  
 
## Basics

* Objects are born and objects die. They have their own lifecycle which we decide. We decide when and how we **construct** it, and we decide when we **destroy** them.
* But in Java,we don't actually *destroy* them, we simply abandon them. Once these objects are abandoned, **Garbage Collector(gc)**, destroys them and reclaims the memory that the object was using. Without garbage collection, we risk running our of RAM.

### The Stack and the Heap

* When a JVM starts up, it gets a chunk of memory from the underlying OS and it uses it to run our JAVA program. 

* In JAVA, we care about two areas of memory which JVM creates for itself - **Heap** (*also known as garbage collectible heap*)- where objects live and **Stack** - where method invocations and local variables live.

* Whenever we create any object, it’s always created in the Heap space. **Garbage Collection runs only on the heap memory to free the memory used by objects that doesn’t have any reference**. Any object created in the heap space has global access and can be referenced from anywhere of the application.

* Stack memory size is very less compared to Heap memory.

### Kinds of variables

* Where a variable lives depends on what kind of variable it is. By *kind* we don't mean *type* (primitive or object reference). The two kinds of variables are **Instance variables** and **local variables**. 

* **Instance variables**: Instance variables are declared inside a class but *not* inside a method.They represent the fields that each object has, which can be filled with different values, for each instance of class. Instance variables live inside the object they belong to. Eg variables like ```size``` below:
```java
public class Duck{
  int size;
}
```

* **Local Variable**: Local variables are declared inside a method, including method parameters. They are temporary and live only as long as the method is on the stack. (In other words, as long as the method has not reached the closing curly braces.). In below snippet, the parameter ```x``` and variables ```i``` and ```b``` are all local variables. 

```java
public void foo(int x){
    int i = x+3;
    boolean b =true;
}
```

### Where do methods live
* When we call a method, the method is pushed into the top of **call stack**. This thing which is pushed is called as *stack frame*, it holds the state of the method including the value of local variables, which line of code is executing etc.

* The method at the top of the stack is always the currently-running method for that stack. A method stays on the stack until the method hits its closing curly brace (which means the method’s done). If method ```foo()``` calls method ```bar()```, method ```bar()``` is stacked on top of method ```foo()```.

* Look at the below snippet:

```java
public void doStuff() {
   boolean b = true;
   go(4);
}
public void go(int x) {
   int z = x + 24;
   crazy();
   // imagine more code here
}
public void crazy() {
   char c = 'a';
}
```

* The code has three methods. The first method ```doStuff()``` calls the second method ```go()```, and the second method calls the third ```crazy()```. Each method declares one local variable within the body of the method, and method ```go()``` also declares a parameter variable (which means ```go()``` has two local variables).This is what happens in the call stack:
  * Code from another class calls ```doStuff()```, and ```doStuff()``` goes into a stack frame at the top of the stack.The boolean variable named ```b``` goes on the ```doStuff()``` stack frame.
  * ```doStuff()``` calls ```go()```, ```go()``` is pushed on top of the stack. Variables ```x``` and ```z``` are in the ```go()``` stack frame.
  * ```go()``` calls ```crazy()```, ```crazy()``` is now on the top of the stack, with variable ```c``` in the frame.
  * ```crazy()``` completes, and its stack frame is popped off the stack. Execution goes back to the ```go()``` method, and picks up at the line following the call to ```crazy()```.
  
  ![methods are stacked](https://github.com/shubhamgupta2901/cheatsheets/blob/master/assets/method%20stack.jpg)

### Where do local variables live

* Local variables live inside the stack frames of the method in the stack.There scope is limited to the method and soon as the method finishes, and its stack frame is popped from the stack, the variables are also destroyed. 

* Primitive variables hold the bits that represent its value. So when a method declares or creates a primitive variable , it goes in the stack , i.e. stack frame of the method.For example, if we have following source code:

```java
public void doStuff(){
 int b;
}
```
![local primitive variable](https://github.com/shubhamgupta2901/cheatsheets/blob/master/assets/local%20primitive%20variable.jpg)

* A non-primitive variable holds a *reference* to an object, not the object itself. In other words, these variables hold the bits that represent a reference to the actual object.  Remember objects live in heap. It doesn’t matter where they’re declared or created. **If the local variable is a reference to an object, only the variable (the reference) goes on the stack.The object itself still goes in the heap.**

```java
public class StackRef {
   public void foof() {
      barf();
   }

   public void barf() {
      Duck d = new Duck(24);
   }
}
```
![hfj](https://github.com/shubhamgupta2901/cheatsheets/blob/master/assets/Screenshot%20from%202018-08-09%2000-02-02.png)


### Where do instance variables live

*  **Instance variables live on the Heap, inside the object they belong to.** 

```java
public class CellPhone {
  int x= 23;
}
```

* When you say new ```CellPhone()```, Java has to make space on the Heap for that ```CellPhone``` object. But how much space? Enough for the object, which means enough to house all of the object’s instance variables.

* **Primitive Instance variable**:  Values of an object’s instance variables live inside the object. If the instance variables are all primitives, Java makes space for the instance variables based on the primitive type. An ```int``` needs 32 bits, a ```long``` 64 bits, etc. Java doesn’t care about the value inside primitive variables; the bit-size of an ```int``` variable is the same (32 bits) whether the value of the ```int``` is 32,000,000 or 32.

```java
public class CellPhone {
  int x;
  long y;
}
```
![instance primitive variable](https://github.com/shubhamgupta2901/cheatsheets/blob/master/assets/instance%20primitive%20variable.jpg)

* **non-primitive Instance variables**: But what if the instance variables are references to objects? Like in our example , CellPhone has a reference variable of type Antenna.

```java
public class CellPhone {
  private Antenna ant = new Antenna();
}
```
*  Consider a use case where the object has instance variables that are object references rather than primitives, In this case too, JAVA stores their values inside the object in the heap. But remember that a **reference variable value is not the whole object, but merely a reference to the object**. The value represented by a non primitive instance variable is bits that represent a reference to actual object.So if ```CellPhone``` has an instance variable declared as the non-primitive type ```Antenna```, Java makes space within the ```CellPhone``` object only for the ```Antenna’s``` reference (i.e. reference variable) but not the ```Antenna``` object.

* Well then when does the ```Antenna``` object get space on the Heap? First we have to find out when the ```Antenna``` object itself is created. That depends on the instance variable declaration. If the instance variable is declared but no object is assigned to it, then only the space for the reference variable  is created.No actual Antenna object is made on the heap unless or until the reference variable is assigned a new Antenna object like below:

```java
public class CellPhone {
  private Antenna ant = new Antenna();
}
```
![non primitive instance variable](https://github.com/shubhamgupta2901/cheatsheets/blob/master/assets/non%20primitive%20instance%20variable.jpg)

### Object creation

* Now that we know where variables and objects live, we can understand object creation. 

* There are three steps of object declaration and assignment: 
   * declare a reference variable,
   * create an object
   * and assign the object to the reference.

* So when an object is created (because somebody said ```new```), the object gets space for all the instance variables, from all the way up the inheritance tree.  When an object is created, it’s almost as though multiple objects materialize—the object being created and one object per each superclass. But it’s much better to think of it like the picture below, where the object being created has layers of itself representing each superclass.

* So when a new object is created, only one object gets space in the heap - the one which is created.But it contains all the parts of itself, and the super class parts of itself which it inherited. All instance variables from both class have to be here.
* For example if we create instance of a class ```Hipp``` which extends ```Animal```, it always has a parent, ```Object``` class. Only one object of ```Hippo``` is created, but it contains all the parts of itself which it inherited.  

```java
public class Animal{
 Foo k;
 int x,v;
}

public class Hippo extends Animal{
 Foo X,Y;
}
```

![object creation](https://github.com/shubhamgupta2901/cheatsheets/blob/master/assets/object%20creation.jpg)

### How long does object live

* An object’s life depends entirely on the life of references referring to it. If the reference is considered alive, the object is still alive on the Heap. If the reference dies, the object will die.

* *How long do variable live?* That depends on whether the variable is a local variable or an instance variable. The code below shows the life of a local variable. In the example, the variable is a primitive, but variable lifetime is the same whether it’s a primitive or reference variable.

![life of a local variable](https://github.com/shubhamgupta2901/cheatsheets/blob/master/assets/life%20of%20a%20local%20variable.jpg)

* **A local variable** lives only within the method that declared the variable, in other words its scope is only within its own method. No other code in the class can see the local variable.  It is *alive* as long as its Stack frame is on the Stack, i.e. until the method completes. Once the method completes and its stack frame is popped from the stack, the local variables scoped in the method are destroyed too.

* Consider following example:

```java
public void doStuff() {
   boolean b = true;
   go(4);
}
public void go(int x) {
   int z = x + 24;
   crazy();
   // imagine more code here
}
public void crazy() {
   char c = 'a';
}
```

* This is what happens in the call stack:
  * ```doStuff()``` goes on the Stack. Variable ```b``` is alive and in scope.
  * ```go()``` is pushed on top of the Stack. ```x``` and ```z``` are alive and in scope, and ```b``` is alive but not in scope.
  * ```crazy()``` is pushed onto the Stack, with ```c``` now alive and in scope. The other three variables are alive but out of scope.
  * ```crazy()``` completes and is popped off the Stack, so ```c``` is out of scope and *dead*. When ```go()``` resumes where it left off, ```x``` and ```z``` are both alive and back in scope. Variable ```b``` is still alive but out of scope (until ```go()``` completes).

* While a local variable is alive, its state persists. As long as method ```doStuff()``` is on the Stack, for example, the ```b``` variable keeps its value. But the ```b``` variable can be used only while ```doStuff()```’s Stack frame is at the top. In other words, you can use a local variable only while that local variable’s method is actually running (as opposed to waiting for higher Stack frames to complete).

* **Reference variables**: The rules are the same for primitives and references. A reference variable can be used only when it’s in scope, which means you can’t use an object’s reference unless you’ve got a reference variable that’s in scope. 

* *How does variable life affect object life?*: An object is alive as long as there are live references to it. If a reference variable goes out of scope but is still alive, the object it refers to is still alive on the Heap. 

* **What happens when the Stack frame holding the reference gets popped off the Stack at the end of the method?** If that was the only live reference to the object, the object is now abandoned on the Heap. The reference variable disintegrated with the Stack frame, so the abandoned object is now, officially, garbag and now becomes eligible for garbage collection.**An object becomes eligible for GC when its last live reference disappears.**

* Once an object is eligible for garbage collection (GC), you don’t have to worry about reclaiming the memory that object was using. If your program gets low on memory, GC will destroy some or all of the eligible objects, to keep you from running out of RAM. You can still run out of memory, but not before all eligible objects have been hauled off to the dump. Your job is to make sure that you abandon objects (i.e, make them eligible for GC) when you’re done with them, so that the garbage collector has something to reclaim. If you hang on to objects, GC can’t help you and you run the risk Out Of Memory error.

* An object’s life has no meaning, no point, unless somebody has a reference to it. If you can’t get to it, you can’t ask it to do anything and it’s just waste of memory. If an object is unreachable, the Garbage Collector will figure that out. Sooner or later, that object will be garbage collected.

* There are three ways to get rid of object reference:
 1. **The reference gets out of scope, permanently.**

```java
 void go(){
 Life z = new Life();
 }
```
Here reference ```z``` dies at the end of the method. Lets look at another example:
```java
public class StackRef {
   public void foof() {
      barf();
   }

   public void barf() {
      Duck d = new Duck();
   }
}
```
* First ```foof()``` is pushed onto the Stack, no variables are declared. ```barf()``` is pushed onto the Stack, where it declares a reference variable, and creates a new object assigned to that reference. The object is created on the Heap, and the reference is alive and in scope.```barf()``` completes and pops off the Stack. Its frame disintegrates, so ```d``` is now dead and gone.The object ```d``` was referencing to is not elligible for garbage collection. Execution returns to ```foof()```, but ```foof()``` can’t use ```d```.
 
 2. **The reference is assigned another object**
```java
Life z = new Life();
z = new Life();
```
* The first object is abandoned, when ```z``` is provided reference of a new object. Lets look at another example:
```java
public class ReRef {
    Duck d = new Duck();
    public void go() {
      d = new Duck();
    }
}
```
* Here ```d``` is instance variable. So ```d``` lives in the heap inside an object of ```Reref```. It will live as long as the ```ReRef``` object that instantiated it is alive. A ```Duck``` object is created in the heap, and its reference is assigned to ```d```.  We are interested in the lifecycle of this ```Duck``` object.

* Since ```d``` will live as long as the object of ```ReRef``` (which instantiated it) is alive, this ```Duck``` too can live as long. but as soon as ```go()``` is called a new object of ```Duck``` is created and is assigned to ```d```. The first object of ```Duck``` is left abandoned. That first ```Duck``` is now as good as dead.

![abandoning object](https://github.com/shubhamgupta2901/cheatsheets/blob/master/assets/abandoning%20object%20way%202.jpg)

 3. **The reference is explicitly set to null**
```java
Life z = new Life();
z = null;
```
The first object is abandoned when we make the value of ```z``` null. Look at the following example: 

```java
public class ReRef {

    Duck d = new Duck();

    public void go() {
      d = null;
    }
}
```

* The new ```Duck``` goes on the Heap, referenced by ```d```. Since ```d``` is an instance variable, the ```Duck``` will live as long as the ```ReRef``` object that instantiated it is alive. Unless ```d``` is set to null, in which case the ```Duck``` object is abandoned and is elligible for garbage collection.

* 




