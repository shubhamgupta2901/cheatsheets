## Multithreading in JAVA

### Contents
  * [Processes](#processes)
  * [Threads](#threads)
  * [Ways to create threads in JAVA](#ways-to-create-threads-in-java)
  * [Thread vs Runnable](#thread-vs-runnable)
  * [Volatile keyword](#volatile-keyword) 
  * [synchronized keyword](#synchronized-keyword)
    * [Multiple Locks in JAVA](#multiple-locks-in-java)
    * [synchronized blocks](#synchronized-blocks)
    * [synchronized blocks vs synchronized methods](#synchronized-blocks-vs-synchronized-methods)
  * [Thread Pools](#thread-pools)
  * [Producer Consumer Problem](#producer-consumer-probler)
    * [Blocking Queue](#blocking-queue)
    * [Internal Implementation of Blocking Queue](#internal-implementation-of-blocking-queue)
  * [Inter thread communication](#inter-thread-communication)
    * [Polling](#polling)
    * [wait and notify](#wait-and-notify)

* In the beginning, computers didn’t have operating systems and only had one CPU; they executed a single program from beginning to end, and that program had direct access to all the resources of the machine. Running only a single program at a time was an inefficient use of expensive and scarce computer resources.

* Later came **multitasking** which meant that computers could execute multiple programs at the same time.  It ran each program in a **process**. Processes are isolated, independently executing programs to which the OS allocates memory, file handles and other resources. 

* If they needed to, processes could communicate with one another through a variety of communication mechanisms: sockets, signal handlers, shared memory, semaphores, and files.

* It wasn't really "at the same time" though. The single CPU was shared between the programs. The operating system would switch between the programs running, executing each of them for a little while before switching.( Modern computers, though, come with multi core CPUs).

* The same concerns (resource utilization, fairness, and convenience) that motivated the development of processes also motivated the development of threads. Threads allow multiple streams of program control flow to coexist within a process. They share process-wide resources such as memory and file handles, but each thread has its own program counter, stack, and local variables. 

* 

* **Multithreading**: Then came multithreading which means that you could have multiple threads of execution inside the same program. Multithreaded programs are able to simultaneously execute multiple sequences of instructions. Each instruction sequence has its own unique flow of control that is independent of all others. These independently executed instruction sequences are known as **threads**.Mutliple threads in a program are reading and writing the same memory simultaneously.
Threads are not complete processes in and of themselves. They are a separate flow of control that occurs within a process.

* **Physical vs Logical Concurrency**: In single CPU systems, only a single thread of execution occurs at a given instant. The CPU quickly switches back and forth between several threads to create the illusion that the threads are executing at the same time. This is **logical concurrency**.Single-processor systems support **logical concurrency**, not physical concurrency.

* On multiprocessor systems, several threads execute at the same time, and **physical concurrency** is achieved.

### Thread
* Threads are the basic units of scheduling.It is an independent path of execution within a program. 
* Many threads can run concurrently within a program.They can execute simultaneously and asynchronously with respect to one another. 
* Since threads share the memory address space of their owning process, all threads within a process have access to the same variables and allocate objects from the same heap. 
* Since threads have access to shared data in a process, a thread may modify variables that another thread is in the middle of using, with unpredictable results.
*   Every thread in Java is created and controlled by the ```java.lang.Thread class```.
* All Java programs have at least one thread, known as the **main thread**, which is created by the Java Virtual Machine (JVM) at the program’s start, when the ```main()``` method is invoked with the main thread.


### Ways to create Threads in JAVA
There are two ways to start a thread in JAVA: 
  1. One is extend ```Thread``` class and override the implmentation of ```run()```.
  
  ```java
  
  class Runner extends Thread {

    String threadNumber;

    public Runner(String threadNumber) {
        this.threadNumber = threadNumber;
        System.out.println("Thread " + threadNumber + " initialized.");
    }


    public void run() {

        for (int i = 0; i < 5; i++) {
            System.out.println("Thread " + threadNumber + ": " + i+" | ");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

public class Demo1 {

    /**
     * When we run main(), we can see that the two threads are running concurrently.
     * Notice we have called {@link Thread#start()} and not {@link Thread#run()}
     * This is because calling run() will run the code in the main thread of the application. So when {@link Thread#sleep(long)} method is called
     * it causes the currently executing thread to sleep (temporarily cease  execution), which is the main thread() and the code is run in sequential manner.
     * <p>
     * Calling start() will start a new thread, which will call run() in that thread, and interleaved output can be observed. Which means both the threads
     * are running concurrently.
     *
     * @param args
     */
    public static void main(String[] args) {

       
        System.out.println("Main thread enter ");

        Runner runner1 = new Runner(String.valueOf(1));
        runner1.start();

        Runner runner2 = new Runner(String.valueOf(2));
        runner2.start();

        System.out.println("Main thread exit ");  


    }

}

```

OUTPUT: 
```java
Main thread enter 
Thread 1 initialized.
Thread 2 initialized.
Main thread exit 
Thread 2: 0 | Thread 1: 0 | Thread 2: 1 | Thread 1: 1 | Thread 2: 2 | Thread 1: 2 | Thread 2: 3 | Thread 1: 3 | Thread 2: 4 | Thread 1: 4 | 


OR 

Main thread enter 
Thread 1 initialized.
Thread 2 initialized.
Main thread exit 
Thread 1: 0 | Thread 2: 0 | Thread 1: 1 | Thread 2: 1 | Thread 1: 2 | Thread 2: 2 | Thread 1: 3 | Thread 2: 3 | Thread 1: 4 | Thread 2: 4 | 

```

* Once the thread is initialized, we can call ```start()``` to start the execution of code written inside ```run()```. NOtice we have called ```start()``` and not ```run()```. This is because calling ```run()``` will run the code in the currently executing thread which wants to start this thread,in this case the main thread of application, and the code is run is sequential manner.

In that case the output would look something like this:

OUTPUT:
```java
Main thread enter 
Thread 1 initialized.
Thread 1: 0 | Thread 1: 1 | Thread 1: 2 | Thread 1: 3 | Thread 1: 4 | Thread 2 initialized.
Thread 2: 0 | Thread 2: 1 | Thread 2: 2 | Thread 2: 3 | Thread 2: 4 | Main thread exit 

```

ii.Second way is to start a thread in JAVA is to make your class implement ```Runnable``` and override ```run()```.Then we can pass this as a parameter to constructor of Thread class.
    
```java
    class Runner2 implements  Runnable{


    String threadNumber;

    public Runner2(String threadNumber) {
        this.threadNumber = threadNumber;
        System.out.println("Thread "+ threadNumber+" initialized.");
    }


    @Override
    public void run() {

        for (int i = 0; i < 5; i++) {
            System.out.print("Thread "+ threadNumber+": " + i+" | ");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

    }
 }
public class Demo2 {
    public static void main(String[] args) {
        Thread thread  = new Thread(new Runner2("1"));
        thread.start();

        Thread thread2  = new Thread(new Runner2("2"));
        thread2.start();
    }
}
```

OUTPUT: 
```java
Thread 1 initialized.
Thread 2 initialized.
Thread 2: 0 | Thread 1: 0 | Thread 2: 1 | Thread 1: 1 | Thread 2: 2 | Thread 1: 2 | Thread 2: 3 | Thread 1: 3 | Thread 2: 4 | Thread 1: 4 | 


OR 

Thread 1 initialized.
Thread 2 initialized.
Thread 1: 0 | Thread 2: 0 | Thread 1: 1 | Thread 2: 1 | Thread 1: 2 | Thread 2: 2 | Thread 1: 3 | Thread 2: 3 | Thread 1: 4 | Thread 2: 4 | 

```
NOTE: If we call the ```run()``` instead of ```start()``` while creating the thread, the code inside ```run()``` will be executed but in the thread of calling method. In the above example it will run of main thread.

## Thread vs Runnable

  * Java doesn't support multiple inheritance, which means we can only extend one class in Java. So once we extend Thread class we can not extend or inherit another class in Java. But when we implement Runnable, we can save a space for our class to extend any other class in future or now.
  
* The most significant difference is: 
  * When we extend Thread class, each of our thread  which we create will have unique object associated with it.
  * When you implements Runnable,many threads can share the same object instance of Runnable.In other words, In the ```Runnable``` interface approach, only one instance of a class is being created and it has been shared by different threads.
 
 * In Object oriented programming extending a class generally means adding new functionality, modifying or improving behaviors. If we are not making any modification on Thread then use Runnable interface instead. If we are not trying to overwrite any behavior, but trying to use behavior of Thread by running it, use of Runnable is preferred. 
 
 * Inheriting all Thread methods are additional overhead just for representing a Task which can be done easily with Runnable.
 
 * Runnable interface represent a Task which can be executed by either plain Thread or **Executors** or any other means. so logical separation of Task as Runnable than Thread is good design decision.
 
 
 * For example:
 
 ```java
 public class MyRunnable implements Runnable {

    private  int count = 0;
    @Override
    public void run() {
        count++;
        System.out.println(MyRunnable.class.getSimpleName()+ " count: "+ count);
    }
}
 ```
 
 ```java
 public class MyThread extends Thread {

    private int counter = 0;

    @Override
    public void run() {
        counter++;
        System.out.println(MyThread.class.getSimpleName() + " count :" + counter);
    }
}
 
 ```
```java

package javaconcepts.multithreading.test;

/**
 * Created by shubham on 3/9/18
 */
public class App {
    public static void main(String[] args) throws InterruptedException {

        MyThread thread1 = new MyThread();
        MyThread thread2 = new MyThread();
        MyThread thread3 = new MyThread();
        
        
        thread1.start();
//        waiting for 1 second before the start of new thread.
        Thread.sleep(1000);
        thread2.start();
        Thread.sleep(1000);
        thread3.start();


        MyRunnable myRunnable = new MyRunnable();
        Thread runnableThread1 = new Thread(myRunnable);
        Thread runnableThread2 = new Thread(myRunnable);
        Thread runnableThread3 = new Thread(myRunnable);

        Thread.sleep(1000);
        runnableThread1.start();
        Thread.sleep(1000);
        runnableThread2.start();
        Thread.sleep(1000);
        runnableThread3.start();

    }
}



```

* The output of the above code is:

```java

MyThread count :1
MyThread count :1
MyThread count :1
MyRunnable count: 1
MyRunnable count: 2
MyRunnable count: 3
```

* In the ```Runnable``` interface approach, only one instance of a class is being created and it has been shared by different threads. So the value of counter is incremented for each and every thread access. Whereas, Thread class approach, you must have to create separate instance for every thread access. Hence **different memory is allocated for every class** instances and each has separate counter, the value remains same, which means no increment will happen because none of the object reference is same.

* **When to use Runnable**: Use Runnable interface when you want to access the same resource from the group of threads. Avoid using Thread class here, because multiple objects creation consumes more memory and it becomes a big performance overhead.

* Interface inheritance (implements) is preferable – This makes your code is loosely coupling between classes/objects.(Note : Thread class internally implements the Runnable interface) so purer composition.

* 



## Volatile keyword

Consider the following example: 

```java
class Runner3 implements  Runnable{
    boolean running  = true;run

    @Override
    public void run() {
        //Background thread
        while(running){
            System.out.println("Hello");
            try {
                Thread.sleep(300);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

    }

    public void stopRunning(){
        this.running = false;
    }
}
public class Demo3 {

    public static void main(String[] args) {
        Runner3 runner = new Runner3();
        Thread thread = new Thread(runner);
        thread.start();

        Scanner sc = new Scanner(System.in);
        sc.nextLine();

        runner.stopRunning();

    }
}
```

* As you can see, the value of ```running``` is never changed from the background thread. It is changed by a method that is called in the main thread of application. Which means the variable running is used by two threads.The expected behaviour of the above block of code is, Hello will keep printing, till somebody presses the Enter key.  And mostly the above code works fine.
* In certain machines, or implementation of language, **the value of running may be cached by the background thread**.The thread might think that the value of ```running``` is never modified by me, so it can cache the value of ```running```. And everytime the while loop checks the value of ```running```, it is accessed from the cache and the value is always true. Which means when you press enter the while loop does not stop running.

* To prevent such kind of ambiguous behaviour we should declare running as volatile. **Volatile is used to prevent threads caching variables when they are not changed from within the thread**.

* So our code would be: 

```java
class Runner3 implements  Runnable{

    volatile boolean running  = true;

    @Override
    public void run() {
        //Background thread
        while(running){
            System.out.println("Hello");
            try {
                Thread.sleep(300);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

    }

    public void stopRunning(){
        this.running = false;
    }
}
public class Demo3 {

    public static void main(String[] args) {
        Runner3 runner = new Runner3();
        Thread thread = new Thread(runner);
        thread.start();

        Scanner sc = new Scanner(System.in);
        sc.nextLine();

        runner.stopRunning();

    }
}

```

### synchronized keyword

 
*  Lets have a look at following example to understand the use of synchronized keyword. In the ```doWork()```, We have created two threads which increment the value of ```count``` 10000 times. `variable ``count``` belongs to the main thread, but when we run these two threads they will try to access the variable from two threads, concurrently.

```java
public class Demo4 {

    private int count = 0;

    public static void main(String[] args) throws Exception {
        Demo4 demo = new Demo4();
        demo.doWork();
    }

    public void doWork() throws InterruptedException {

        Thread thread1 = new Thread(() -> {
            for (int i = 0; i < 10000; i++)
                count++;
        });

        Thread thread2 = new Thread(() -> {
            for (int i = 0; i < 10000; i++)
                count++;
        });

        thread1.start();
        thread2.start();

        /**
         * {@link Thread} class provides the join() method which allows one thread to wait until another thread completes its execution.
         * If t is a Thread object whose thread is currently executing, then t.join(); it causes the current thread to pause its execution
         * until thread of t completes its execution.
         */

        thread1.join();
        thread2.join();
        System.out.println(count);
    }
}
```
* The expected value of ```count``` here is 20000.Because both the threads are incrementing the value of count 10000 times each.
* However if I run the code, it can be seen that the value of count is not always 20000(It is less than 20000).The reason for this is ```count++ or count = count+1``` is actually a three step instruction to computer.
 1. **FETCH** the value of ```count```.
 2. **INCREMENT** the value of ```count```.
 3. **UPDATE** the incremented value to ```count```.

* Since both the threads are concurrently using the ```count``` variable,there is a possibility that the value of ```count``` is INCREMENTED by ```thread1``` but before UPDATING,the value of ```count``` is FETCHED by ```thread2```.Suppose the value of count is 100, ```thread1``` INCREMENTS the value, but before UPDATING the value, ```thread2``` FETCHES the value of ```count``` which is still 100 so ```thread2``` increments 100 to 101, and now ```thread1``` updates the value of ```count``` to 101. but actually ```count``` should have been incremented from 100 to 101 to 102.
         
* It can ofcourse be lot worse than that , like while ```thread2``` is reading the value of ```count```, ```count``` has already incremented it twice but before ```thread1's``` UPDATE, ```thread2's``` FETCH occurs.

*  **Solution:**  Above, it can be seen that some of the increments of ```count``` has been skipped, because both the threads read the value concurrently and before the increment operation was completed and value was updated, the other thread would fetch the unupdated value and increment it.What we really need to do is, we need to find some way of making sure that in that time when a thread reads the value of ```count```,incrments and stores it back to ```count```, no other thread should access it and changed it. Hence the concept of ```synchronized```.
 
 * To remove above issue, I can create a method ```increment()``` which increments the value of ```count``` and replace it with increment expressions from both the loops. Then I will make the method ```incrment()``` synchronized.
 
* Every object in JAVA has an intrinsic lock (monitor lock or mutex).If you want call a **synchronized** method of an object, you have to acquire the intrinsic lock before you can call it. 

 * Only one thread can acquire this lock in the object at a time. So when one thread acquires this lock and runs ```increment()``` and if another thread tries to call the method,then the second thread will have to wait until the first thread releases the intrinsic lock which happens when the method finshes execution.


``` java 
public class Demo5 {


    int count = 0;

    private synchronized void increment(){
        count++;
    }

    private void doWork() throws InterruptedException {
        Thread thread1 = new Thread(() -> {
            for(int i = 0; i<100000; i++)
               increment();
        });
        Thread thread2 = new Thread(()->{
            for(int i = 0; i<100000; i++)
                increment();
        });

        thread1.start();
        thread2.start();

        thread1.join();
        thread2.join();

        System.out.println(count);
    }

    public static void main(String[] args) throws Exception {
        Demo5 demo = new Demo5();
        demo.doWork();
    }
}
```

OUTPUT:
```java
20000
```
         
### Multiple Locks in JAVA

* Consider the following code. The ```main()``` of ```App``` creates a new ```Worker``` object and calls it ```main``` (just public void main)

```java

public class App {
    public static void main(String[] args) {
        Worker worker = new Worker();
        worker.main();
    }
}
```

```java
public class Worker {
    private Random random = new Random();
    private List<Integer> list1 = new ArrayList<>();
    private List<Integer> list2 = new ArrayList<>();


    public void main()  {
        System.out.println("Starting...");
        long start = System.currentTimeMillis();

        process();

        long end = System.currentTimeMillis();
        System.out.println("Time taken: "+ (end-start));
        System.out.println("List1: "+list1.size());
        System.out.println("List2: "+list2.size());
    }

    /**
     * We are trying to simulate a network call, which will give us a new element.
     * This new element is added  to list1
     */
    public  void stageOne() {
        try {
            Thread.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        int num = random.nextInt();
        list1.add(num);
    }

    /**
     * We are trying to simulate a network call, which will give us a new element.
     * This new element is added  to list2
     */
    public  void stageTwo()  {
        try {
            Thread.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        int num = random.nextInt();
        list2.add(num);
    }

    public void process()  {
        for (int i = 0;i<1000; i++){
            stageOne
            stageTwo();
        }

    }
}

```

OUTPUT :
```java
Starting...
Time taken: 2212
List1: 1000
List2: 1000

```
* The above code will take around 2000ms to create the lists of size 1000 each, which is expected. 
* We may want to speed things up, by running multiple threads at the same time. We can ask ```process()``` to add only 500 elements in each list, and we can have two threads running ```process()``` at the same time. So we can add 1000 elements in each list in only 1000ms.
* ThreadPool will be ideal for this type of situatuion, which can allow us to create a bunch of threads, but for this example lets stick to only two threads.
* The changes we will make are 

```java

public void process()  {
        for (int i = 0;i<500; i++){
            stageOne();
            stageTwo();
        }

    }
```

and 
```java
  public void main()  {
        System.out.println("Starting...");
        long start = System.currentTimeMillis();

        Thread thread1 =new Thread(new Runnable() {
            @Override
            public void run() {
                process();
            }
        });

        Thread thread2 =new Thread(new Runnable() {
            @Override
            public void run() {
                process();
            }
        });

        thread1.start();
        thread2.start();

        try {
            thread1.join();
            thread2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }


        long end = System.currentTimeMillis();
        System.out.println("Time taken: "+ (end-start));
        System.out.println("List1: "+list1.size());
        System.out.println("List2: "+list2.size());
    }
```

* After making these changes when we run the application, following output is generated:
```java
Starting...
Time taken: 1130
List1: 965
List2: 964

```
* We can clearly see that although it takes ~1000 ms to add elements in the lists, the size of lists is always lesser than 1000. This is because of thread interleaving and are normal problems which we can expect if we try to access shared data from multiple threads, (because writing to a list is not a single step operation).

* So we know that we have to make the methods synchronized. This way a lock can be obtained on the object when one of them is changing its state and the other will wait. 

* Following changes are made:

```java
 public  synchronized void stageOne() {
        try {
            Thread.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        int num = random.nextInt();
        list1.add(num);
    }

   
    public synchronized void stageTwo()  {
        try {
            Thread.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        int num = random.nextInt();
        list2.add(num);
    }
```

* The output generated fixes the problem of thread interleaving, and 1000 elements are added in each lists. Output looks like this:
```java
Starting...
Time taken: 2225
List1: 1000
List2: 1000
```
* The problem is, it is taking ~2000 ms. This is twice as long as we would expect.The reason for this problem is: when you call ```synchronized``` method from a thread, it is going to acquire the intrinsic lock of the ```Worker``` object 


### Thread Pools
* Thread pools are a way of managing lots of threads at the same time.

* Server Programs such as database and web servers repeatedly execute requests from multiple clients  at the same time.They generally need to process a large number of short tasks. 

* One approach for building a such application would be to create a new thread each time a request arrives and service this new request in the newly created thread. 

* While this approach seems simple to implement, it has significant disadvantages. A server that creates a new thread for every request would spend more time and consume more system resources in creating and destroying threads than processing actual requests.

* This is because Thread objects use a significant amount of memory, and in a large-scale application, allocating and deallocating many thread objects creates a significant memory management overhead.

* Since active threads consume system resources, a JVM creating too many threads at the same time can cause the system to run out of memory. This necessitates the need to limit the number of threads being created.

* **A thread pool reuses previously created threads to execute current tasks and offers a solution to the problem of thread cycle overhead and resource thrashing**. Since the thread is already existing when the request arrives, the delay introduced by thread creation is eliminated, making the application more responsive.

* A Thread Pool creates a certain number of threads for excuting list of given tasks. It then processes number of tasks on given number of ideal thread. Once a thread completes its execution and is ideal again, It is again alloted a task from the list of current given tasks.

* For example: Consider that we have 5 different tasks. To process this we create a ThreadPool of 3 threads. We submit the list of tasks to ThreadPool Executor. It places all the tasks in a queue and executes task in idle threads. 


![Thread Pool 1](https://github.com/shubhamgupta2901/cheatsheets/blob/master/assets/Thread_Pool.jpg)

* All threads are being currently run by the executor then the pending tasks in  queue and are executed when a thread becomes idle.

![Thread Pool 2](https://github.com/shubhamgupta2901/cheatsheets/blob/master/assets/Thread%20pool%202.jpg)

![Thread Pool 3](https://github.com/shubhamgupta2901/cheatsheets/blob/master/assets/Thread%20Pool%203.jpg)

Example: Consider following example:

```java
public class RunnableTask implements Runnable {
    private int id;
    private long submissionTime;

    public RunnableTask(int id, long submissionTime) {
        this.id = id;
        this.submissionTime = submissionTime;
    }

    @Override
    public void run() {
        long startTime = System.currentTimeMillis() - submissionTime;

        System.out.println("Starting Task "+ id+"| Started " + startTime+ " milliseconds after submitting the task.");

        //Simulate some asynchronus work. Like handling requests which takes ~5 seconds
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        long timeTaken = System.currentTimeMillis() - submissionTime;
        System.out.println("Completed Task "+ id +" | " + timeTaken+"  milliseconds after submitting the task.");

    }
}
```

```java
  public static void main(String[] args) {

        //Creating a thread pool of two threads.
        ExecutorService executorService  = Executors.newFixedThreadPool(2);


        //Submitting the list of tasks to be done to executor service
        for(int i = 1; i<=5; i++){
            executorService.submit(new RunnableTask(i,System.currentTimeMillis()));
        }
        //Excutorservice is shut down. We will not be able to submit new tasks after this. It will not shutdown immediately but will wait for all the threads to complete doing what they are doing.
        executorService.shutdown();
        System.out.println("All tasks submitted");

        // similar to Thread.join(), Blocks the current thread until all tasks have completed execution after a shutdown request, or the timeout occurs,  whichever happens first. Here we want to actually wait for all the tasks to complete so we wait for their termination. Parameters define what is the time we want to wait before time out. 
        try {
            executorService.awaitTermination(1, TimeUnit.DAYS);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("All tasks completed.");
    }
```

OUTPUT: It may look something like this: 
```java
All tasks submitted
Starting Task 2| Started 8 milliseconds after submitting the task.
Starting Task 1| Started 2 milliseconds after submitting the task.
Completed Task 2 | 5106  milliseconds after submitting the task.
Starting Task 3| Started 5104 milliseconds after submitting the task.
Completed Task 1 | 5111  milliseconds after submitting the task.
Starting Task 4| Started 5104 milliseconds after submitting the task.
Completed Task 3 | 10104  milliseconds after submitting the task.
Starting Task 5| Started 10105 milliseconds after submitting the task.
Completed Task 4 | 10105  milliseconds after submitting the task.
Completed Task 5 | 15105  milliseconds after submitting the task.
All tasks completed.

```
 ### Producer Consumer Problem
 
* Producer–consumer problem (also known as the bounded-buffer problem) is an example of a multi-thread synchronization problem. The problem describes two processes, the **producer** and the **consumer**, which share a common, fixed-size buffer used as a queue.
* The producer’s job is to generate data, put it into the buffer, and start again.
* At the same time, the consumer is consuming the data (i.e. removing it from the buffer), one piece at a time.
* **Problem**: We have to make sure that the producer won’t try to add data into the queue if it is full and that the consumer won't try to remove data from queue if it is empty.
* **Solution**  The producer is to either go to sleep or discard data if the queue is full. The next time the consumer removes an item from the buffer, it notifies the producer, who starts to fill the queue again. In the same way, the consumer can go to sleep if it finds the queue to be empty. The next time the producer puts data into the queue, it wakes up the sleeping consumer.

   ### Blocking Queue

* A **Blocking Queue** is a queue that blocks when you try to dequeue from it and the queue is empty, or if you try to enqueue items to it and the queue is already full. 

* A thread trying to dequeue from an empty queue is blocked (prompted to wait) until some other thread inserts an item into the queue. 

* A thread trying to enqueue an item in a full queue is blocked(prompted to wait) until some other thread makes space in the queue, either by dequeuing one or more items or clearing the queue completely. 

* **It is thread safe**. We can access this from multiple threads and not have to worry about thread synchronization.

* It can be used for **implementation of Producer Consumer**: The idea of Producer consumer is, we have one or more threads that produce things (producer) and add to a common data structure, and we have other thread remove things from this data structure and process it (consumer). 

```java
public class App {

    private static BlockingQueue<Integer> queue = new ArrayBlockingQueue<Integer>(10);

    public static void main(String[] args) {

        Thread producerThread = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    producer();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });


        Thread consumerThread = new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    consumer();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });

        producerThread.start();
        consumerThread.start();


        try {
            producerThread.join();
            consumerThread.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    private  static void producer() throws InterruptedException {
        Random random = new Random();
        while (true){
            queue.put(random.nextInt(100));
        }
    }

    private static void consumer() throws InterruptedException {
        Random random = new Random();
        while (true){
            //Thread.sleep(100);

            if(random.nextInt(10) == 0){
                Integer value = queue.take();
                System.out.println("Taken value: "+ value+"; Queue size: "+ queue.size());
            }
        }
    }
}
```

OUTPUT: 
```java
Taken value: 66; Queue size: 9
Taken value: 92; Queue size: 9
Taken value: 17; Queue size: 10
Taken value: 12; Queue size: 9
Taken value: 36; Queue size: 9
Taken value: 59; Queue size: 9
Taken value: 0; Queue size: 10
Taken value: 8; Queue size: 9
Taken value: 7; Queue size: 9
Taken value: 44; Queue size: 9
.
.
.
```

* producer() will loop indefinitely, generating random numbers and adding it to the queue.
* consumer() loops indefinitely too. It sleeps for a while and then a random number is generated between 0 and queue size. If this index is 0 then item is removed from queue.

   #### Internal Implementation of Blocking Queue
 * Producer consumer problem can be efficiently solved using Java's ```BlockingQueue``` class. However if we create our own data structure to solve the problem we can understand how ```wait()``` and ```notify()``` works.


