## OOPS

### Contents
  * [Objects](#objects)
  * [Classes](#classes)
  	* [Nested Classes](#nested-classes)
		* [Non static Member Inner Classes](#non-static-member-inner-classes)
		* [Local Inner Classes](#local-inner-classes)
		* [Anonymous classes](#anonymous-classes)
  * [Access Modifiers](#access-modifiers)
  * [static keyword](#static-keyword)
    * [static blocks](#static-blocks)
    * [static variables](#static-variables)
    * [static methods](#static-methods)
    * [static classes](#static-classes)
  * [Constructors](#constructors)
    * [How does constructors work](#how-does-constructors-work)
    * [Types of constructors](#types-of-constructors)
    * [Constructor Overloading](#constructor-overloading)
    * [Constructor Chaining](#constructor-chaining)
    * [Private constructors](#private-constructors)
    * [Constructors of Sub and Super Classes](#constructors-of-sub-and-super-classes)
    * [Constructors in Abstract classes](#constructors-in-abstract-classes) 
    * [Static constructors ?](#static-constructors-?)
    * [Constructors in Abstract Classes](#constructors-in-abstract-classes)
    * [Summary](#summary)
  *  []()
  
  ## Classes
   ### Nested Classes
  * Check [this](https://javaconceptoftheday.com/nested-classes-in-java/)
  * A class within a class in called nested class.
  * They enable you to logically group classes that are only used in one place, thus this increases the use of encapsulation.
  * The scope of a nested class is bounded by the scope of its enclosing class.
  * Nested class has access to the members, including private members, of the class in which it is nested. However, reverse is not true i.e. the enclosing class does not have access to the members of the nested class.
  * Since a nested class is also a member of its enclosing class , **it can be declared private, public, protected or default** (Unlike classes which can not be private or protected).
  
  
  * Nested classes can be of two types:
   * [static nested classes](#static-classes)
   * non-static classes
    1.  Member Inner class
    2.  Anonymous Inner class
    3.  Local Inner class
   
   #### Non static Member Inner classes
   
   * It is a class which is created inside a class, but not inside a method.
   * The java compiler creates two class files in case of inner class. The class file name of inner class is ```"Outer$Inner"```. **If you want to instantiate inner class, you must have to create the instance of outer class**. In such case, instance of inner class is created inside the instance of outer class.
   * To instantiate an inner class, you must first instantiate the outer class. Then, create the inner object within the outer object with this syntax:
   
   ```java
   OuterClass.InnerClass innerObject = outerObject.new InnerClass();
   ```
   
  * Syntax: 
  ```java
  class OuterClass
{
...
    class NestedClass
    {
        ...
    }
}
  ```

* Example: 

```java
class Outer{  
 private int data=30;  
 class Inner{  
  void msg(){System.out.println("data is "+data);}  
 }  
 public static void main(String args[]){  
  Outer outerObj=new Outer();  
  Outer.Inner in=outerObj.new Inner();  
  in.msg();  
 }  
}  
```

OUTPUT: 
```java
data is 30
```


#### Local Inner Classes

* Local Inner Classes are the inner classes that are defined inside a block. This block can be either a method body, initialization block, for loop or even an if statement..The scope of local inner class will be restricted to the block they are defined in.
* Local Inner classes are not a member of any enclosing classes. They belong to the block they are defined within, due of which local inner classes cannot have any access modifiers associated with them.
* **Local Inner class cannot be declared as static**. Inner classes are associated with the block they are defined within and not with the external class(Outer in this case).
* However, **they can be marked as final or abstract**. If they are marked abstract, then all the abstract methods inside the class needs to be implemented by the class which will extend it(The inherited class also needs to be in same scope).If you declare it as final , no class in the scope of this class can override it.
* Also, feel free to extend these 
* If you want to instantiate such local inner classes, it must be done in the block they are defined in (same scope).
* These class have access to the fields of the class enclosing it. 
* Till JDK 7,Local inner class can access only final local variable of the enclosing block. However From JDK 8, it is possible to access the non-final local variable of enclosing block in local inner class.

* Exaple: 
```java
public class Outer
{
    private void getValue()
    {
        // Note that local variable(sum) must be final till JDK 7 
        // hence this code will work only in JDK 8
        int sum = 20;
         
        // Local inner Class inside method
        class Inner
        {
            public int divisor;
            public int remainder;
             
            public Inner()
            {
                divisor = 4;
                remainder = sum%divisor;
            }
            private int getDivisor()
            {
                return divisor;
            }
            private int getRemainder()
            {
                return sum%divisor;
            }
            private int getQuotient()
            {
                System.out.println("Inside inner class");
                return sum / divisor;
            }
        }
         
        Inner inner = new Inner();
        System.out.println("Divisor = "+ inner.getDivisor());
        System.out.println("Remainder = " + inner.getRemainder());
        System.out.println("Quotient = " + inner.getQuotient());
    }
     
    public static void main(String[] args)
    {
        Outer outer = new Outer();
        outer.getValue();
    }
}

```
OUTPUT:
```java
Divisor = 4
Remainder = 0
Inside inner class
Quotient = 5
```

* Another example:

```java
public class Outer
{
    public int data = 10;
    public int getData()
    {
        return data;
    }
    public static void main(String[] args)
    {
        Outer outer = new Outer();
        if(outer.getData() < 20)
        {
            // Local inner class inside if clause
            class Inner
            {
                public int getValue()
                {
                    System.out.println("Inside Inner class");
                    return outer.data;
                }
            }
  
            Inner inner = new Inner();
            System.out.println(inner.getValue());
        }
        else
        {
            System.out.println("Inside Outer class");
        }
    }
}
```
OUTPUT:
```java
Inside Inner class
10
```

## Anonymous Classes

* It is an inner **class without a name** and for which **only a single object is created**. 
* Anonymous inner classes are useful in writing implementation classes for listener interfaces. Like onclick listeners in android.
* Lets understand it using an example:

```java
//Java program to demonstrate need for Anonymous Inner class
interface Age
{
    int x = 21;
    void getAge();
}
// Myclass implement the methods of Age Interface
class MyClass implements Age
{
    @Override
    public void getAge() 
    {
        // printing the age
        System.out.print("Age is "+x);
    }
}

class AnonymousDemo
{
    public static void main(String[] args) 
    {
        // Myclass is implementation class of Age interface
        MyClass obj=new MyClass();
 
        // calling getage() method implemented at Myclass
        obj.getAge();     
    }
}
```
* In the program, interface ```Age``` is created with ```getAge()``` method and ```x=21```.  ```Myclass``` is written as implementation class of ```Age``` interface. And we finally instantiate it in  ```AnonymousDemo```.

* 


  
## Access Modifiers 
  * The The access modifiers in java specifies accessibility (scope) of a class,method,constructor or data member.
  * In java we have four access modifiers:
  1. private
  2. default
  3. protected
  4. public
  
  * **Private** : The scope of private modifier is limited to the class only.
   1. Private Data members and methods are only accessible within the class
   2. Class and Interface **cannot** be declared as private
   3. If a class has private constructor then you cannot create the object of that class from outside of the class.
   
  Example: 
  ```java
class A{  
private int data=40;  
private void msg(){System.out.println("Hello java");}  
}  
  
public class Simple{  
 public static void main(String args[]){  
   A obj=new A();  
   System.out.println(obj.data);//Compile Time Error  
   obj.msg();//Compile Time Error  
   }  
}  
  ```
  For private constructors:
  ```java
class A{  
private A(){}//private constructor  
void msg(){System.out.println("Hello java");}  
}  
public class Simple{  
 public static void main(String args[]){  
   A obj=new A();//Compile Time Error  
 }  
}  
  ```
  
 * **Default** :When we do not mention any access modifier, it is called default access modifier.The scope of this modifier is limited to the package only. This means that if we have a class with the default access modifier in a package, only those classes that are in this package can access this class. No other class outside this package can access this class. Similarly, if we have a default method or data member in a class, it would not be visible in the class of another package.
 
 Example:
 
 ```java
package pack;  
class A{  
  void msg(){System.out.println("Hello");}  
}  
 ```
 
 ```java
package mypack;  
import pack.*;  
class B{  
  public static void main(String args[]){  
   A obj = new A();//Compile Time Error  
   obj.msg();//Compile Time Error  
  }  
}  
 ```
 
 * **protected** Protected data members and methods are only accessible by the classes of the same package and the subclasses present in any package.
 * **Classes cannot be declared protected.**
 Example:
 ```java
package pack;  
public class A{  
protected void msg(){System.out.println("Hello");}  
}  
 ```
 
 ```java
 package mypack;  
import pack.*;  
  
class B extends A{  
  public static void main(String args[]){  
   B obj = new B();  
   obj.msg();  
  }  
}  
 ```
 OUTPUT: 
 ```java
 Hello
 ```
 
 * **public** The members, methods and classes that are declared public can be accessed from anywhere. This modifier doesn’t put any restriction on the access.
 
 Example: 
 ```java
package pack;  

public class A{  
public void msg(){System.out.println("Hello");}  
}
```

```java
package mypack;  
import pack.*;  
  
class B{  
  public static void main(String args[]){  
   A obj = new A();  
   obj.msg();  
  }  
}  
```
  
| Access Modifier | within class | within package | outside package by subclass only | outside package |
|-----------------|--------------|----------------|----------------------------------|-----------------|
| Private         | Y            | N              | N                                | N               |
| Default         | Y            | Y              | N                                | N               |
| Protected       | Y            | Y              | Y                                | N               |
| Public          | Y            | Y              | Y                                | Y               |
  
  
   ## static keyword
  * *static* is a non-access modifier in Java which is applicable for the following:
   1. blocks
   2. variables
   3. methods
   4. nested classes
   
   * **When a member is declared static, it can be accessed before any objects of its class are created**, and without reference to any object.This is because, a static member belongs to a class and not to a instance of class. For example, in below java program, we are accessing static method ```m1()``` without creating any object of Test class.
   
  ```java
  class Test
{
    // static method
    static void m1()
    {
        System.out.println("from m1");
    }
 
    public static void main(String[] args)
    {
          // calling m1 without creating
          // any object of class Test
           m1();
    }
}

  ```
  From outside the class:
  ```java
   class A
{
 
    public static void main(String[] args)
    {
          // calling m1 without creating
          // any object of class Test
           Test.m1();
    }
}
  ```
  * **This is the reason why ```main()``` method in JAVA are static, because it needs to be invoked before any objects of that class are created.**
  
  
  	### static blocks

* static blocks (also called static clause) can be used for static initializations of a class. This code inside static block is executed only once:the first time a class is loaded by JVM (typically, when a static member of class is accessed or when a instance of the class is created). For example: 
```java
public class Test {
    static int a = 10;
    static int b;

    static {
        System.out.println("Static block intialized");
        b = a*4;
    }
    public static void main(String [] args){
       
    }
}
```

Output:
```java
Static Block Intialized
```

The above class is loaded because JVM has to access this class' ```main()```. For following code: 

```java
public class Test {
    static int a = 10;
    static int b;

    static {
        System.out.println("Static block intialized");
        b = a*4;
    }
}

public class Main {
    public  static void main(String [] args){
        System.out.println("a: "+Test.a);
        System.out.println("b:  "+Test.b);
    }
}

```
Output: 
```java
Static block intialized
a: 10
b:  40
```
* Also static blocks are initialized before constructors. See the output for the following example:

```java
public class Test {
    static int a = 10;
    static int b;

    static {
        System.out.println("Test Static block intialized");
        b = a*4;
    }

    Test(){
        System.out.println("Test Constructor initialized");
        a *= 2;
        b *= 2;
    }
}

public class Main {
    public  static void main(String [] args){

        System.out.println("a: "+Test.a);
        System.out.println("b:  "+Test.b);

        Test test = new Test();

        System.out.println("a: "+Test.a);
        System.out.println("b: "+Test.b);
    }

}
```
OUTPUT:
```java
Test Static block intialized
a: 10
b:  40
Test Constructor initialized
a: 20
b: 80
```

* Static blocks are also executed only once. IN the following code, it can seen that the static block is executed only once, as soon as the class is loaded. 
```java
class Test {
    static int i;
    int j;
    static {
        i = 10;
        System.out.println("Test Static block intialized");
    }
    Test(){
        System.out.println("Test Constructor initialized");
    }
}
 
class Main {
    public static void main(String args[]) {
 
       // Although we have two objects, static block is executed only once.
       Test t1 = new Test();
       Test t2 = new Test();
    }
}
```

OUTPUT: 
```java
Test Static block intialized
Test Constructor initialized
Test Constructor initialized
```
* Static blocks are called when class is loaded by the JVM into memory. Once class is loaded , it is there in memory , it is not loaded again and again, hence static blocks are called only once. 

* **Multiple static blocks**: Classes can have multiple static blocks in java. They execute in the given order which means the first static block executes before second static block.

Example:

```java
class JavaExample2{
   static int num;
   static String mystr;
   //First Static block
   static{
      System.out.println("Static Block 1");
      num = 68;
      mystr = "Block1";
  } 
  //Second static block
  static{
      System.out.println("Static Block 2");
      num = 98;
      mystr = "Block2";
  }
  public static void main(String args[])
  {
      System.out.println("Value of num: "+num);
      System.out.println("Value of mystr: "+mystr);
   }
}
```

OUTPUT: 
```java
Static Block 1
Static Block 2
Value of num: 98
Value of mystr: Block2
```

* **static blocks with inheritance** Consider the following code:

```java
class A {
    static {
        System.out.println("loading A static 1");
    }
    static {
        System.out.println("loading A static 2 B.c= "+B.c);        
    }
    static {
        System.out.println("loading static 3");
    }
    static int a=10; 
    A(){        
    }
}

class B extends A{
    static {
       System.out.println("loading B A.a= "+A.a);
    }
    static int c = 50;
}
public class Test {
    public static void main(String[] args) {
        new B();
    }
}

```
Output of the above code will be:

```java
loading A static 1
loading A static 2 B.c= 0
loading static 3
loading B A.a= 10
```

* To understand the above output, lets understand how classes with inheritance are loaded by JVM.
	1. If a class has already been loaded, return the class
	2. Load the parent class first.
	3. Try and load the class itself.
	
* We can check this by executing it with java -verbose Test:
```java
...
[Loaded A from file:/.../src/main/java/]
[Loaded B from file:/.../src/main/java/]
loading A static 1
loading A static 2 B.c= 0
loading static 3
loading B A.a= 10
...
```
 * **Constructors, Inheritance and static blocks** Consider following snippet of code: 
 
```java
public class Parent {    
    public Parent() {
        System.out.println("Parent Constructor");
    }    
    static {
        System.out.println("Parent static block");    
    }    
  
}

public class Child extends Parent {    
    static {
        System.out.println("Child static block");
    }

    public Child() {
        System.out.println("Child Constructor");
    }    
    public static void main(String[] args) {
        new Child();    
    }
}
```

OUTPUT of the following code will be: 

```java
Parent static block
Child static block
Parent Constructor
Child Constructor
```

* This is what is going on:
 1. Parent class is loaded first by Java.
 2. As soon as the parent class is loaded, its static block will be executed.
 3. Then the child class will be loaded.
 4. As soon as the child class is loaded, its static block will be executed.
 5. ```main()``` of ```Child``` is invoked.
 6. constructor of ```Child``` is called. 
 7. constructor of ```Child``` first calls the constructor of its super class, implicitly.
 8. So constructor of ```Parent``` is exceucted first, then constructor of ```Child``` class.
 
 
   	### static variables
 * When a variable is declared as static, then a single copy of variable is created and shared among all objects at class level.  
 * Static variables are, essentially, global variables, so **there can be no local static variables**.
 * All instances of the class share the same static variable, that is why (unlike non-static variables) **such variables can be accessed directly in static and non-static methods**.
 * static method directly accessing static variables:
 ```java
 class JavaExample3{
  static int var1;
  static String var2;
  //This is a Static Method
  static void disp(){
      System.out.println("Var1 is: "+var1);
      System.out.println("Var2 is: "+var2);
  }
  public static void main(String args[]) 
  {
      disp();
  }
}
 ```
 
 OUTPUT:
 ```java
Var1 is: 0
Var2 is: null
 ```
 
 * non-static methods accessing static variables:
```java
public class Test {
    static int a = 10;
    static int b;

   static void display(){
       System.out.println("display:" + a);
   }

   //non static method accessing the static variable
    // they can access static methods as well.
   void nonStaticDisplay(){
       System.out.println("nonStaticDisplay:" +a);
   }

   public static void main(String[] args){
       //Creating instance of Test class and accessing the class' static variable through an instance
       Test obj  = new Test();
       obj.nonStaticDisplay();

       System.out.println("Test.a: "+ Test.a);
       Test.display();
       //When an instance changes the value of a static variable,
       // it actually changes the value for everyone, because this variable belongs to class.
       obj.a = 1000;

       System.out.println("obj.a:"+obj.a);
       System.out.println("Test.a: "+Test.a);
       Test.display();
   }
}

```
OUTPUT:
```java
nonStaticDisplay:10
Test.a: 10
display:10
obj.a:1000
Test.a: 1000
display:1000
```
It can be seen from the above example, that when an object changes the value of a static variable, the value of that variable changes for all objects, it makes sense because the members belong to the class and all objects access the same variable.

* As shown above, **Static variables are shared among all the instances of class**. Lets have another look: 
```java
class JavaExample{
   //Static integer variable
   static int var1=77; 
   //non-static string variable
   String var2;

   public static void main(String args[])
   {
	JavaExample ob1 = new JavaExample();
	JavaExample ob2 = new JavaExample();
	/* static variables can be accessed directly without
	 * any instances. Just to demonstrate that static variables
	 * are shared, I am accessing them using objects so that 
	 * we can check that the changes made to static variables
	 * by one object, reflects when we access them using other
	 * objects
	 */
        //Assigning the value to static variable using object ob1
	ob1.var1=88;
	ob1.var2="I'm Object1";
        /* This will overwrite the value of var1 because var1 has a single 
         * copy shared among both the objects.
         */
        ob2.var1=99;
	ob2.var2="I'm Object2";
	System.out.println("ob1 integer:"+ob1.var1);
	System.out.println("ob1 String:"+ob1.var2);
	System.out.println("ob2 integer:"+ob2.var1);
	System.out.println("ob2 STring:"+ob2.var2);
   }
}

```
OUTPUT: 
```java
ob1 integer:99
ob1 String:I'm Object1
ob2 integer:99
ob2 STring:I'm Object2
```
* In this example, String variable is non-static and integer variable is Static. As you can see in the output that the non-static variable is different for both the objects but the static variable is shared among them, thats the reason the changes made to the static variable by object ob2 reflects in both the objects.

* **static block and static variables are executed in order they are present in a program,as soon as the class is loaded by JVM** Static variables are initialized when class is loaded, they are initialized before any object of that class is created, they are initialized before any static method of the class executes.
Check the below snippet:

```java
class Test
{
    // static variable
    static int a = m1();
     
    // static block
    static {
        System.out.println("Inside static block");
    }
     
    // static method
    static int m1() {
        System.out.println("from m1");
        return 20;
    }
     
    // static method(main !!)
    public static void main(String[] args)
    {
       System.out.println("Value of a : "+a);
       System.out.println("from main");
    }
 
 
}
```
OUTPUT:
```java
from m1
Inside static block
Value of a : 20
from main
```
* **static final variables** The static final variables are constants. Check below snippets:
```java
public class MyClass{
   public static final int MY_VAR=27;
}
```
* The above code will execute as soon as the class ```MyClass``` is loaded, before static method is called and even before any static variable can be accessed. The variable ```MY_VAR``` is public which means any class can use it. It is a static variable so you won’t need any object of class in order to access it. It’s final so the value of this variable can never be changed in the current or in any class.

  ### static methods
  
* Here are some points of observation:
  	1. Non-static methods and non-static variables can only be accessed using object (instance) of the class.
	2. Static methods and variables can be accessed directly without creating the objects.
	3. Static methods can access other static variables without using object.
	4. But for static methods to access non-static methods and variables, instance of the class is required.
* For example, static method ```main()``` accesses the static variables directly here:
  
  ```java
  class JavaExample{
   static int i = 10;
   static String s = "Beginnersbook";
   //This is a static method
   public static void main(String args[]) 
   {
       System.out.println("i:"+i);
       System.out.println("s:"+s);
   }
}
  ```
  OUTPUT: 
  ```java
i:10
s:Beginnersbook
  ```
 * In below example, Static method  is accessed directly in static and non-static method

```java
class JavaExample{
  static int i = 100;
  static String s = "Beginnersbook";
  //Static method
  static void display()
  {
     System.out.println("i:"+i);
     System.out.println("i:"+s);
  }

  //non-static method
  void funcn()
  {
      //Static method called in non-static method
      display();
  }
  //static method
  public static void main(String args[])
  {
	  JavaExample obj = new JavaExample();
	  //You need to have object to call this non-static method
	  obj.funcn();
	  
      //Static method called in another static method
      display();
   }
}
```

OUTPUT:

```java
i:100
i:Beginnersbook
i:100
i:Beginnersbook
```

#### static classes

* Refer [Nested classes](#nested-classes) 
* **A class can be made static only if it is a nested class.**
* As with class methods and variables, a static nested class is associated with its outer class. And like static methods, a static nested class cannot refer directly to instance variables or methods defined in its enclosing class: it can use them only through an object reference.
* They are accessed using the enclosing class name, similar to non-static inner classes.Like: 
```java
OuterClass.StaticNestedClass
```
* However unlike non-static inner classes,to create an object of a nested static class, you do not need the object of parent class.:
```java
//static inner classes do not need its parent class object to be created.
OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass();
```
* Remember object of non-static class was created like this:
```java
OuterClass outerObject = new OuterObject();
//non-static inner classes need an object of parent class, to which they belong to for creating the class.
OuterClass.InnerClass innerObject = outerObject.new InnerClass();
```
* For example: 
```java
class OuterClass
{ 
    // static member
    static int outer_x = 10;
     
    // instance(non-static) member
    int outer_y = 20;
     
    // private member
    private static int outer_private = 30;
     
    // static nested class
    static class StaticNestedClass
    {
        void display()
        {
            // can access static member of outer class
            System.out.println("outer_x = " + outer_x);
             
            // can access display private static member of outer class
            System.out.println("outer_private = " + outer_private);
             
            // The following statement will give compilation error
            // as static nested class cannot directly access non-static membera
            // System.out.println("outer_y = " + outer_y);
         
        }
    }
}


public class StaticNestedClassDemo
{
    public static void main(String[] args)
    {
        // accessing a static nested class.
        OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass();
         
        nestedObject.display();
         
    }
}
```

OUTPUT:

```java
outer_x = 10
outer_private = 30
```
* Static nested classes do not directly have access to other members(non-static variables and methods) of the enclosing class because as it is static, it must access the non-static members of its enclosing class through an object. That is, it cannot refer to non-static members of its enclosing class directly. Because of this restriction, static nested classes are seldom used.
* Non-static nested classes (inner classes) has access to all members(static and non-static variables and methods, including private) of its outer class and may refer to them directly in the same way that other non-static members of the outer class do.



  
  ## Constructors
  * Constructor is block of code(similar to method) which is used to initialize an object. It is called when an instance of object is created (using ```new``` ) and memory is allocated to object.
  * The constructor name matches with the class name and it doesn’t have a return type.
   
   #### How does constructors work
   A default constructor in a class looks like this. A default constructor is a constructor which does not take any parameter.
  
  ```java
   public class Hello {
   String name;
   
   // Constructor
   Hello(){
      this.name = "Shubham";
   }
   
   public static void main(String[] args) {
      Hello obj = new Hello();
      System.out.println(obj.name);
   }
}
  ```
   When we create object of the above class :
  ```java
   Hello obj = new Hello(); 
  ```
  OUTPUT of ```main()```
  ```java
  Shubham
  ```
  The ```new``` keyword here creates a new object of class ```Hello``` by allocating memory. ```obj``` is then assigned the value of this memory's reference.
  The constructor is invoked in the object to initialize the values of this newly created object. So once the constructor is called the value of ```name``` in for object ```obj``` will be ```Shubham```.
  
  #### Types of Constructors 
  * **Default Constructor**  If we do not implement any constructor in our class, Java inserts a default constructor to the code in our behalf. This initializes the object's variable with default values of their respective data types.
  * Default constructors are not visible in the source code, as they are inserted at the time of compilation when you have not provided any constructor explicitly.
  * If you provide a constructor to your, then the default constructor is not generated by the compiler.
  * Consider the following example: 
 ```java 
  public class Hello {
   String name;
}
 ```
  Since no other constructor is provided in the class, at the time of compilation, a default constructor is provided by the compiler. So the class essentially looks something like this; 
  ```java 
  public class Employee {
   String name;
   int credits;
   boolean isActive;
   
   Employee(){
    name = null;
    credits = 0; 
    isActive = false;
   }
}
 ```
 * The default constructor is the no-argument constructor automatically generated unless you define another constructor. It initialises any uninitialised fields to their default values.
 
 * *Why default constructor?* 
 
 * **No-argument constructor** A no-argument constructor is similar to the default constructor in a sense that it also does not take any parameter but unlike default constructor, it is explicitly defined by user.
 * Example: 
```java 
  public class Employee {
   String name;
   int credits;
   boolean isActive;
   
   Employee(){
    credits = 25; 
    isActive = true;
   }
}
```
 In the above example, use of no-argument constructor can be seen, you want all the objects created to be initialised with default values, which are different than the data type provided values. So when the objects of ```Employee``` class is created, all of them will have 25 credits and will be active, when they are initialized.
 
 * NOTE: The compiler automatically provides a no-argument, default constructor for any class without constructors. This default constructor will call the no-argument constructor of the superclass. In this situation, the compiler will complain if the superclass doesn't have a no-argument constructor so you must verify that it does. If your class has no explicit superclass, then it has an implicit superclass of Object, which does have a no-argument constructor.
 
 * **Parameterized Constructors** Constructors which take parameters are called parameterized constructor. They are used to provide different values to the distinct objects at the time of initialization.

 
 Example: 
 
 ```java
 public class Employee {

   int empId;  
   String empName;  
	    
   //parameterized constructor with two parameters
   Employee(int id, String name){  
       this.empId = id;  
       this.empName = name;  
   }  
   void info(){
        System.out.println("Id: "+empId+" Name: "+empName);
   }  
	   
   public static void main(String args[]){  
	  Employee obj1 = new Employee(10245,"Chaitanya");  
	  Employee obj2 = new Employee(92232,"Negan");  
	  obj1.info();  
	  obj2.info();  
   }  
}
 ```
 Output:
```java
Id: 10245 Name: Chaitanya
Id: 92232 Name: Negan
```

#### Constructor Overloading 

* Just like methods, constructors can also be overloaded. Since constructors don't have a return type, we can overloading is obtained solely on basis of difference in types and number of arguments.
So a class can have as many constructors (with different signatures) as you want.
 ```java
 class Example
{
      private int var;
      //no arg constructor
      public Example()
      {
             this.var = 10;
      }
      //parameterized constructor
      public Example(int num)
      {
             this.var = num;
      }
      public int getValue()
      {
              return var;
      }
      public static void main(String args[])
      {
              Example2 obj = new Example2();
              Example2 obj2 = new Example2(100);
              System.out.println("var is: "+obj.getValue());  //Output var is: 0
              System.out.println("var is: "+obj2.getValue()); // Output var is: 100
      }
}
 ```
 
 In the above example, we have two constructors, a default constructor and a parameterized constructor. When we do not pass any parameter while creating the object using new keyword then default constructor is invoked, however when you pass a parameter then parameterized constructor that matches with the passed parameters list gets invoked.(Compile time polymorphism or static binding.)

* *C++'s copy constructor is a parameterized constructor in Java.* There is no copy constructor in java. But, we can copy the values of one object to another like copy constructor in C++.
```java
class Student6{  
    int id;  
    String name;  
    Student6(int i,String n){  
    id = i;  
    name = n;  
    }  
      
    Student6(Student6 s){  
    id = s.id;  
    name =s.name;  
    }  
    void display(){System.out.println(id+" "+name);}  
   
    public static void main(String args[]){  
    Student6 s1 = new Student6(111,"Karan");  
    Student6 s2 = new Student6(s1);  
    s1.display();  
    s2.display();  
   }  
}  

```

Output of the above code: 
```java
111 Karan
111 Karan
```

* **When you only implement parameterized constructor?** When you don’t implement any constructor in your class, compiler inserts the default constructor into your code, however when you implement any constructor (in above example I have implemented parameterized constructor with int parameter), then you don’t receive the default constructor by compiler into your code.

Example: 
```java
class Example3
{
      private int var;
      public Example3(int num)
      {
             var=num;
      }
      public int getValue()
      {
              return var;
      }
      public static void main(String args[])
      {
              Example3 myobj = new Example3();
              System.out.println("value of var is: "+myobj.getValue());
      }
}
```

The above code generates compile time error, as it is not able to find the constructor with no arguments.If we remove the parameterized constructor from the above code then the program would run fine, because then compiler would insert the default constructor into your code.

#### Constructor Chaining

* **We can chain constructors.** When A constructor calls another constructor of same class then this is called constructor chaining. 
* This can be achieved by using ```this``` keyword.If you want to invoke a parameterized constructor then do it like this: ```this(parameter list)```.
Example: 
```java
class Employee
{   
    public String empName;
    public int empSalary;
    public String address;

    //default constructor of the class
    public Employee()
    {
    	//this will call the constructor with String param
        this("Chaitanya");
    }

    public Employee(String name)
    {
    	//call the constructor with (String, int) param
    	this(name, 120035);
    }
    public Employee(String name, int sal)
    {
    	//call the constructor with (String, int, String) param
    	this(name, sal, "Gurgaon");
    }
    public Employee(String name, int sal, String addr)
    {
    	this.empName=name;
    	this.empSalary=sal;
    	this.address=addr;
    }

    void disp() {
    	System.out.println("Employee Name: "+empName);
    	System.out.println("Employee Salary: "+empSalary);
    	System.out.println("Employee Address: "+address);
    }
    public static void main(String[] args)
    {
        Employee obj = new Employee();
        obj.disp();
    }
}

```
Output: 
```java
Employee Name: Chaitanya
Employee Salary: 120035
Employee Address: Gurgaon
```
* The real purpose of Constructor Chaining is that you can pass parameters through a bunch of different constructors, but only have the initialization done in a single place. This allows you to maintain your initializations from a single location, while providing multiple constructors to the user. If we don’t chain, and two different constructors require a specific parameter, you will have to initialize that parameter twice, and when the initialization changes, you’ll have to change it in every constructor, instead of just the one.

#### Private Constructors

* A Constructor, like a method can have any access modifier. However, if the constructor is private, it can not be invoked from anywhere outside the class. This means the object creation of this class can only happen from inside the class, and not from anywhere else.

* The use of private constructors is to serve **Singleton classes**. A singleton class is one which limits the number of objects creation to one. Using private constructor we can ensure that no more than one object can be created at a time. By providing a private constructor you prevent class instances from being created in any place other than this very class. We will see in the below example how to use private constructor for limiting the number of objects for a singleton class.

* Example: 
```java
public class SingleTonClass {
   //Static Class Reference
   private static SingleTonClass obj=null;
   private SingleTonClass(){
      /*Private Constructor will prevent 
       * the instantiation of this class directly*/
   }
   public static SingleTonClass objectCreationMethod(){
	/*This logic will ensure that no more than
	 * one object can be created at a time */
	if(obj==null){
	    obj= new SingleTonClass();
	}
        return obj;
   }
   public void display(){
	System.out.println("Singleton class Example");
   }
  
}
public class Driver {
public static void main(String args[]){
	//Object cannot be created directly due to private constructor 
        //This way it is forced to create object via our method where
        //we have logic for only one object creation
	SingleTonClass myobject= SingleTonClass.objectCreationMethod();
	myobject.display();
   }
}
```

#### Constructors of Sub and Super Classes
* Creating an object of sub class also invokes the constructor of super class.
Example
```java
class Parent {
    String s;
 
    public Parent(){
    	System.out.println("Parent");
    }
}
 
public class Child extends Parent {
 
    public Child(){
    	System.out.println("Child");
    }
 
    public static void main(String[] args){
    	Sub s = new Child();
    }
}

```
Output of the above code is: 
```java
Parent
Child
```

* When inheriting from another class, super() has to be called first in the constructor. If not, the compiler will insert that call. This is why super constructor is also invoked when a Sub object is created.
* This doesn't create two objects, only one ```Child``` object. The reason to have super constructor called is that if super class could have private fields which need to be initialized by its constructor.
* After compiler inserts the ```Parent``` constructor in the ```Child``` constructor, the code looks like this:
```java
 public Sub(){
    	super();
    	System.out.println("Sub");
    }
```
* This evidently gives rise to a popular error. Since the child constructor implicitly calls the parent constructor. There is always a chance that the ```Parent``` class has not defined any constructor. In this case, compiler provides a default constructor to the ```Parent``` class and everything works fine. In cases when the ```Parent``` class defines a no-argument constructor, then also the code works fine, however, problem arises when the ```Parent``` class implements parameterized constructors, and no no-arg constructors. In this case the compiler does not provide any default constructor, which leads to compile time error: *"Implicit super constructor is undefined for default constructor. Must define an explicit constructor"*.

Example: 
```java
```java
class Parent {
    String s;
 
    public Parent(String s){
    	System.out.println(s);
    }
}
 
public class Child extends Parent {
 
    public Child(){
    	System.out.println("Child");
    }
 
    public static void main(String[] args){
    	Sub s = new Child();
    }
} 

```
* There are two ways you can neglect the problem:
  1. Implement a no-arg constructor in the ```Parent``` class.C
  2. You can explicitly call the parameterized constructor of ```Parent``` inside the ```Child``` class.  In this case we have to ensure that the call to ```Parent``` constructor is first thing we do in the constructor. We use ```super``` keyword for this purpose. 
 * call to constructor of ```Parent``` class is the first thing compiler does while constructing/initializint the ```Child``` object.If you want to explicitly invoke ```Parent``` class' constructor it needs to be the first statement in ```Child``` constructor. **i.e.```super()``` has to be first statement in a constructor.** The parent class' constructor needs to be called before the subclass' constructor. This will ensure that if you call any methods on the parent class in your constructor, the parent class has already been set up correctly. So it saves us from working with partially constructed objects.
 
 ```java
class Parent {
    String s;
 
    public Parent(String s){
    	System.out.println(s);
    }
}
 
public class Child extends Parent {
 
    public Child(){
    	super("Parent");
    	System.out.println("Child");
    }
 
    public static void main(String[] args){
    	Sub s = new Child();
    }
} 
 ```
  
* In brief, the rules is: child class constructor has to invoke parent class instructor, either explicitly by programmer or implicitly by compiler. For either way, the invoked parent constructor has to be defined. 

For example: This generates compile time error: *call to super must be first statement in constructor*
```java
public class MyClass {
    public MyClass(int x) {}
}

public class MySubClass extends MyClass {
    public MySubClass(int a, int b) {
        int c = a + b;
        super(c);  // COMPILE ERROR
    }
}

``` 
#### Static constructors ?
* A constructor can not be marked static. You will get *modifier static not allowed here*.
* It’s actually pretty simple to understand – Everything that is marked static belongs to the class only, for example static   method cannot be inherited in the sub class because they belong to the class in which they have been declared.

* Static methods belong to a class, not an object. Similary for static variables (which can only be accessed by static methods), only one copy exists for the entire class, as opposed to a member variable, which is created once for each object created from a class. They are used to store data for the class. On the other hand, object methods are meant to operate on the data associated with a single instance of a class, an object. Constructors are the code that is used to initialize an object and set it's data to an initial state. They are executed immediately (and automatically) after the memory has been allocated to store a new object. Even if you do not explicitly define a constructor, a kind of "default constructor" is executed in order to map the object's member variables and the object's method code to the new object.So logically it does not make sense for a constructor to be static.

* Another reasoning, Since each constructor is being called by its subclass during creation of the object of its subclass, so if you mark constructor as static the subclass will not be able to access the constructor of its parent class because it is marked static and thus belong to the class only. This will violate the whole purpose of inheritance concept and that is reason why a constructor cannot be static.
Example: 
```java
public class StaticDemo
{
     public StaticDemo()
     {
         /*Constructor of this class*/
         System.out.println("StaticDemo");
     }
}
public class StaticDemoChild extends StaticDemo
{
     public StaticDemoChild()
     {
          /*By default super() is hidden here */
          System.out.println("StaticDemoChild");
     }
     public void display()
     {
          System.out.println("Just a method of child class");
     }
     public static void main(String args[])
     {
          StaticDemoChild obj = new StaticDemoChild();
          obj.display();
     }
}
```

Output:
```java
StaticDemo
StaticDemoChild
Just a method of child class
```

* When we created the object of child class, it first invoked the constructor of parent class and then the constructor of it’s own class. It happened because the new keyword creates the object and then invokes the constructor for initialization, since every child class constructor by default has super() as first statement which calls it’s parent class’s constructor. The statement super() is used to call the parent class(base class) constructor.This is the reason why constructor cannot be static – Because if we make them static they cannot be called from child class thus object of child class cannot be created.

* However **static blocks** do provide an alternative to static constructors.

#### Constructors in Abstract Classes

* **Abstract class can have constructors** and it is defined and behaves just like any other class's constructor. **Except that abstract classes can't be directly instantiated**, only extended, so the use is therefore always from a subclass's constructor.

 * Consider this:
 ```java
 abstract class Product { 
    int multiplyBy;
    public Product( int multiplyBy ) {
        this.multiplyBy = multiplyBy;
    }

    public int mutiply(int val) {
       return multiplyBy * val;
    }
}

class TimesTwo extends Product {
    public TimesTwo() {
        super(2);
    }
}

class TimesWhat extends Product {
    public TimesWhat(int what) {
        super(what);
    }
}
 
 ```
 
 * The superclass ```Product``` is abstract and has a constructor. The concrete class ```TimesTwo``` has a constructor that just hardcodes the value 2. The concrete class ```TimesWhat``` has a constructor that allows the caller to specify the value. Abstract constructors will frequently be used to enforce class constraints or invariants such as the minimum fields required to setup the class.
* You would define a constructor in an abstract class if you are in one of these situations:
  1)  you want to perform some initialization (to fields of the abstract class) before the instantiation of a subclass actually takes place.
  2)  you have defined final fields in the abstract class but you did not initialize them in the declaration itself; in this case, you MUST have a constructor to initialize these fields


#### Summary
* Constructors are not methods and they don’t have any return type.
* Constructor name should match with class name .
* A constructor in Java doesn't actually "build" the object, it is used to initialize fields. Once the memory allocation for the object is done using ```new``` operator, constructor will initialize the fields for that object.
* If you don’t implement any constructor within the class, compiler will do it for you.
* A constructor can also invoke another constructor of the same class – By using this(). If you want to invoke a parameterized constructor then do it like this: this(parameter list).
* * If a class doesn’t have a no-arg(default) constructor then compiler would not insert a default constructor in the class as it does in normal scenario.
*  **Since constructors do not need any object reference to be called, only new operator, so they can be called in static methods as well.** Although constructors are non-static, and belong to instance of class.
* Every class has a constructor whether it’s a normal class or a abstract class. Abstract class can have constructor and it gets invoked when a class, which extends it, is instantiated. (i.e. object creation of concrete class).
* When a child class' constructor is invoked, the first thing it does is invoke the default constructor of parent class (unless theres a explicit call to parent class' constructor, in which case it should be first thing you do in child class' constructor). Remember constructors are only used for initializing the fields of class. So memory is only allocated for child class's object, but the constructor call to parent ensures that all the fileds of parent clss are initialized and are ready to be used by child class.
* Constructor can use any access specifier, they can be declared as private also. Private constructors are possible in java but there scope is within the class only. So new objects can only be created from inside the class if we have private constructors.
* **Like constructors method can also have name same as class name, but still they have return type, though which we can identify them that they are methods not constructors* Constructors are not methods and they don’t have any return type.**
* this() and super() should be the first statement in the constructor code. If you don’t mention them, compiler does it for you accordingly.
* Constructor overloading is possible but **overriding is not possible**. Which means we can have overloaded constructor in our class but we can’t override a constructor.
* Constructors can not be inherited.
* Interfaces do not have constructors.
* Constructors cannot be abstract, final, static and synchronised while methods can be.





 
 
 

  
  
  
  
